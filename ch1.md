# 概述

获取软件需求的本质问题, 其实就是人与人的沟通问题. 需求者必须与开发者进行交流. 一个成功的软件项目需要来自各个方面的信息, 一方面是客户和用户, 有时候包括分析人员, 领域专家和其他从业务或组织视角来审查软甲的人; 另一方面则是技术团队.　　　   

在沟通的过程中, 必须时刻保持对话地位的平衡, 任何一方占据强势, 都会使项目蒙受损失. 如果需求方占据绝对的地位, 他们就只会关注软件的功能和交付的时间, 却很少关注开发人员是否能同时满足这两者, 我们都知道几乎所有的项目都是在有限的资源下进行的, 这意味着有限的时间, 有限的人力, 在这样的前提下, "加入更多的功能"和"按时交付"几乎不可能同时获得. 又或者他们会忽略开发人员是否真正理解了需求, 只管"下达命令",至于怎样实现, "那是开发人员的事情", 这显然将会导致巨大的问题. 而如果技术人员把持主动会怎样呢? 这样一来将会导致技术术语代替业务语言, 从而开发人员无法认真倾听业务方的实际需求, 因为业务方在把需求转换为术语是必然会产生信息的衰减, 这样的过程累积起来, 就会导致最终开发出的产品只是技术团队想象中的东西, 与实际业务脱节.   

我们需要一种协同工作的方法, 让双方都不占据绝对主导地位, 共同来面对由于个人情感倾向导致的问题以及办公室政治的纷争之下的资源分配问题．若资源分配权完全落入一方手中，项目必然失败．如果只让开发人员来承担项目进度的风险，告知他们，＂我不关心你们怎么做，但请务必在６月份之前完成＂，这样的命令看似很酷，却会导致开发人员为了满足时间点的要求而牺牲质量换取更多的功能特性，或者只部分的实现了某些特性，自行做出一些本应在客户参与下才能做出的决定．那么反过来如果这个风险只是由客户和用户来承担，那么会在项目开始之时产生漫长的讨论，由于客户和用户对技术的了解欠缺，基本上难以做出相对正确的估算，为了降低风险，他们将会在讨论中逐渐移除要开发的特性，随着开发的进行，会有更多的功能从计划中移除，最终发布软件时，只剩下很少的一部分功能了．

我们还必须承认的一点是，我们无法完美的预测软件开发项目．这是软件业和传统行业的重大区别之一．当用户看到软件的早起版本时，他们会产生出新的想法，从而改变他们的观点．由于软件的这种不可控性，大部分开发人员都认为＂估计需要多长时间才能完成＂是最困难的一件事．由于这种不确定性和其他的一些因素，导致我们无法做出精确的预期．

那么在承认了这一切之后，我们就应该寻求新的对策．
首先我们根据手头上能够获得的信息，来做出决策，这个决策既不会包含所有细节，也不是一锤定音，它有可能随着项目进展不断改变．事实上为了使之更加符合客户的需要，它必须不断的改变．这首先是一个价值观上的变化，我们从试图在最初计划一切，变为逐步探索，边进行开发边制定计划．当然这种＂随机应变＂式的计划并非没有原则，它必须保证在一个相对短时期内的计划是稳定的，否则将会沦为无计划，使开发人员无所适从．

用户故事，即是为了适应这种分析与计划的方式而生的一种需求收集与描述的手段．

## 什么是用户故事?
用户故事描述了对用户，系统或软件购买者有价值的功能．　用户故事由以下三方组成．
* 一份书面的故事描述, 用来做计划和作为提示.  
* 有关故事的对话, 用于具体化故事细节.  
* 测试, 用于表达和编档故事细节, 并对故事的完成做出定义. 

在传统的方式中用户故事通常使用一张纸质卡片进行描述, 所以以上三点又通常被定义成3C特征, 即卡片(card),对话(conversation),和确认(confirmation). 卡片可能是用户故事最明显的表现形式之一, 但并不是最重要的,卡片上通常是很简略的描述客户的需求而非完全的陈述, 需求的细节内容是在"对话"之中获得的. 

下面是一个典型的用户故事，该故事取自一个旅游行业的内部系统　　
	计调人员可以在系统中发布新的旅行线路
后面将会继续使用这个系统作为案例。

那么从用户故事的定义来说， 首先要体现对用户有*价值*， 上面的例子中， “发布旅行线路”即是该用户故事的价值所在。而下面的例子则不能体现出对用户的价值
	这个旅行线路应该存储在MySQL数据库的tour_product表中
在这个描述之中，涉及了过多的实现细节，而用户显然是不关心数据怎样存储的的。
从实践中我们总结出一个合理的用户故事的描述可以通过填充下面的三部分来表现
	作为____, 我想要____, 以便___    
这三部分分别体现了，该用户故事的主体，即受益者，想要实现的功能，以及最终体现业务的价值。那么按照这个思路，我们可以把上面的用户故事写成如下的形式:  
	作为计调人员，我想要在系统中发布新的旅行线路，以便销售人员可以查找并销售这条线路．
按照这样的形式进行分解之后，用户故事就变得清晰很多了，其中第三部分在某些情况下是可以省略，因为有可能是第二部分已经足够清楚表达意图了。

## 故事的粒度
请看这样的一个故事
	销售人员可以搜索正在销售中的旅行线路
这样的一句话十分简单，但是仅以这样一句话作为指南进行开发，显然还不够。开发人员需要更多的细节，比如

1. 销售人员可以按哪些条件进行检索？城市？ 日期？ 关键字？ 
2. 搜索参数是否需要保存？ 
3. 搜索结果是否需要排序？ 如何排序？ 

这时候，我们需要对故事的粒度进行细分。 如果从大的粒度着眼，很多系统也就那么几个用户故事。比如著名的社交网站twitter，其主要的用户故事大概也就是这样的

1. 用户之间可以彼此follow，以形成朋友关系
2. 用户可以发布消息，以便其朋友可以看到
3. 用户可以转发其朋友发布的消息

这些描述都十分简单，似乎没啥指导性的意义，然而不要小看它们，因为它们确实体现出了twitter核心的业务价值。像这样的故事，我们称之为”史诗故事“(Epic)，通常我们从史诗故事入手，将其逐步分解成更多的小故事。回到最上面的例子”销售人员可以搜索正在销售中的旅行线路“这一故事就可以分解成以下几个故事

1. 销售人员可以通过线路的价格，所在城市，起止时间，发布时间，关键字等条件进行搜索。
2. 销售人员可以查看搜索结果中的每条线路的信息，其中应包括是否有折扣，以及折扣条件等，以便根据用户组团人数进行推荐
3. 销售人员可以查看到该线路是由哪位计调人员发布的，以便必要时和计调人员取得联系。

这样的分解应该进行到什么程度呢？这并没有什么绝对的准则，一条可参考的方案是，当这个故事所描述的粒度达到可以进行估算的范围即可。什么是可估算？通常来说，如果我们估计一至两天以内的工作量时会比较有把握，而估计一周的工作量就开始产生较大的偏差，要估算两个月的工作量，那基本就跟猜的没什么两样。

## 加些注释
对于细分过后的故事，我们可以尝试加入一些注释，如果使用纸质的卡片，那么可以讲这些注释卸载卡片背面，如果使用电子文档比如excel的话，就使用注释功能。这些注释是一些提示语句，可以非常简短，例如上面的故事可以加入如下的一些注释:  

* 注意关键字为空或者超长的情况
* 注意关键字中包含特殊字符的情况

这些注释性的描述主要用于帮助开发人员进行测试，以及确认功能已经完全开发完成。要注意这些一定要简短，不要担心信息不够或者无法读懂，因为我们真正关注的是面对面的沟通，如果开发人员拿到卡片之后看不太懂，那么尽可以去找到卡片的作者与之进行交流，从而获得更加完整的信息。我们想要做的，只是一个提示而已。	

## 客户团队
在一个理想的scrum团队中，都有一个专职的人员负责为开发人员的工作排列优先级，回答开发人员所有的问题，在软件发布一部分功能时对其进行使用并给出反馈，写下更多的用户故事等等。然而像这样的”专职“人员，在大多数的项目中都是很难遇到的，原因是业务人员也有很多自己的工作要做，大多数被指派来给开发人员答疑解惑的业务人员都是将其作为”额外“的工作的，他们的本职工作还是要做好才行。所以，我们需要建立一个客户团队。客户团队中包括确保软件满足用户需求的所有人，这意味着客户团队可以包含测试人员，产品经理/项目经理，实际用户和UI设计师。

## 用户故事在开发过程中的流转
相对于过去的项目，使用故事的项目的开发步调会很不一样。使用传统的瀑布是模型的过程是这样的， 书写所有需求 -> 分析需求 -> 设计方案 -> 编码 -> 最终测试 这样形成一个周期。在这样的过程中，客户和用户只在项目开始阶段进行参与，之后就把开发人员抛弃到一边让他们自生自灭，直到最后阶段来验收软件。现如今大家都知道这样的模型是靠不住的，让开发人员自己搞只能创造出各种各样的灾难。    

而在敏捷型的项目当中，我们需要的是客户和用户在项目整个的生命周期中全程参与进来。软件的客户和最终客户应该在编写故事之时承担着非常活跃的角色，尤其是在团队使用极限编程(XP)进行开发时。编写故事的过程可以从考虑系统的用户类别入手，还是以上面的某旅游行业的内部系统软件为例，会包含计调人员，销售人员，行政人员，采购人员，部门管理者等角色，如果有可能的话，最好能够在客户团队当中包含尽可能多的不同的角色，让他们参与进来，从而获得第一手的用户故事。  

组建起客户团队之后，下一步是召开“故事会”这是类似头脑风暴的一种会议，在这个会议上大家集思广益，收集尽可能多的故事，而后对这些故事进行筛选，细分和优先级排列，最终获得一些可供开发人员参考的故事集合，注意此时我们并不需要分析完所有的故事，只要将一部分高优先级的故事提取出来，足够我们开发一阵子（至少是一至两个迭代的周期），就可以了。然后在接下来的开发过程中，我们会进一步的细化其他的故事。客户团队在这段时间内都是高度参与的，他们会协助定义用户故事的测试用例，甚至与开发人员一起编写运行自动化测试的脚本。客户团队要努力确保项目能够达到交付所需产品的目标。  

迭代长度一经确定，开发人员就会估计每轮迭代中可以做多少事情。这个值被称之为开发速率velocity。团队的第一次速率估计很可能是错误的，因为无法事先预知团队的情况，但是没有关系，我们在后面的迭代中会借鉴前面迭代的速率，甚至绘制出速率的曲线图，来勾勒出大致的发布计划。我们无法做到绝对准确，但是在相对准确上是可以逐渐向事实靠拢的。  

当我们拥有了一堆的故事卡片之后, 我们根据其优先级和依赖顺序来将其分成若干堆, 每一堆都是依据一个迭代可能完成的工作量来进行划分的. 在每一轮迭代开始之前,客户团队可以对迭代中的故事卡片进行修正．这样当迭代结束后，我们就会获知开发团队的实际速率，然后使用它重新来重新估计后面的迭代．由于预估的偏差，我们有可能在每个迭代中对卡片进行调整，增加或者移除都有可能．也有可能在实际的开发过程中会发现某些故事之间的相互依赖关系导致不得不把某些卡片提前，而另一些推迟到下一个迭代中．
## 迭代式发布计划
一个发布由一个或者多个迭代组成．我们需要在项目计划的时间表和预期的功能集合之间做出平衡，这个过程就是发布规划．客户团队和开发人员都需要参与其中．　　
第一件事情是为故事排列优先级．优先级排列需要考量一下几个因素：　
* 大部分用户和客户对特定特性的渴望程度
* 小部分重要用户和客户对特定特性的渴望程度
* 故事之间的关系. 

在排列优先级的过程中，开发人员可能和客户团队的意见不同，原因是他们会基于技术风险方面的考虑,或者由于某个故事是其他故事的前置依赖,而建议改变故事的优先级. 客户团队应该倾听他们的观点，但是在随后排列故事优先级时，还是应该以客户组织的利益最大化为第一原则．　　
排列故事优先级时也应该考虑他们的成本．故事的成本应该由开发者给出，这个成本并非绝对的人＊天值，而是一个相对的数字，称之为故事点数．这里强调一个相对概念，一个２个点的故事，其成本会高于１个点的故事，而一个４个点的故事，其成本大约相当于２个点的故事的２倍．　　
	之后我们可以把评估后的故事列出来，并且形成这样的一个表格


## 验收测试
## 为何采用用户故事