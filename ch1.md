# 概述

获取软件需求的本质问题, 其实就是人与人的沟通问题. 需求者必须与开发者进行交流. 一个成功的软件项目需要来自各个方面的信息, 一方面是客户和用户, 有时候包括分析人员, 领域专家和其他从业务或组织视角来审查软甲的人; 另一方面则是技术团队.　　　   

在沟通的过程中, 必须时刻保持对话地位的平衡, 任何一方占据强势, 都会使项目蒙受损失. 如果需求方占据绝对的地位, 他们就只会关注软件的功能和交付的时间, 却很少关注开发人员是否能同时满足这两者, 我们都知道几乎所有的项目都是在有限的资源下进行的, 这意味着有限的时间, 有限的人力, 在这样的前提下, "加入更多的功能"和"按时交付"几乎不可能同时获得. 又或者他们会忽略开发人员是否真正理解了需求, 只管"下达命令",至于怎样实现, "那是开发人员的事情", 这显然将会导致巨大的问题. 而如果技术人员把持主动会怎样呢? 这样一来将会导致技术术语代替业务语言, 从而开发人员无法认真倾听业务方的实际需求, 因为业务方在把需求转换为术语是必然会产生信息的衰减, 这样的过程累积起来, 就会导致最终开发出的产品只是技术团队想象中的东西, 与实际业务脱节.   

我们需要一种协同工作的方法, 让双方都不占据绝对主导地位, 共同来面对由于个人情感倾向导致的问题以及办公室政治的纷争之下的资源分配问题．若资源分配权完全落入一方手中，项目必然失败．如果只让开发人员来承担项目进度的风险，告知他们，＂我不关心你们怎么做，但请务必在６月份之前完成＂，这样的命令看似很酷，却会导致开发人员为了满足时间点的要求而牺牲质量换取更多的功能特性，或者只部分的实现了某些特性，自行做出一些本应在客户参与下才能做出的决定．那么反过来如果这个风险只是由客户和用户来承担，那么会在项目开始之时产生漫长的讨论，由于客户和用户对技术的了解欠缺，基本上难以做出相对正确的估算，为了降低风险，他们将会在讨论中逐渐移除要开发的特性，随着开发的进行，会有更多的功能从计划中移除，最终发布软件时，只剩下很少的一部分功能了．

我们还必须承认的一点是，我们无法完美的预测软件开发项目．这是软件业和传统行业的重大区别之一．当用户看到软件的早起版本时，他们会产生出新的想法，从而改变他们的观点．由于软件的这种不可控性，大部分开发人员都认为＂估计需要多长时间才能完成＂是最困难的一件事．由于这种不确定性和其他的一些因素，导致我们无法做出精确的预期．

那么在承认了这一切之后，我们就应该寻求新的对策．
首先我们根据手头上能够获得的信息，来做出决策，这个决策既不会包含所有细节，也不是一锤定音，它有可能随着项目进展不断改变．事实上为了使之更加符合客户的需要，它必须不断的改变．这首先是一个价值观上的变化，我们从试图在最初计划一切，变为逐步探索，边进行开发边制定计划．当然这种＂随机应变＂式的计划并非没有原则，它必须保证在一个相对短时期内的计划是稳定的，否则将会沦为无计划，使开发人员无所适从．

用户故事，即是为了适应这种分析与计划的方式而生的一种需求收集与描述的手段．

## 什么是用户故事?
用户故事描述了对用户，系统或软件购买者有价值的功能．　用户故事由以下三方组成．
* 一份书面的故事描述, 用来做计划和作为提示.  
* 有关故事的对话, 用于具体化故事细节.  
* 测试, 用于表达和编档故事细节, 并对故事的完成做出定义. 

在传统的方式中用户故事通常使用一张纸质卡片进行描述, 所以以上三点又通常被定义成3C特征, 即卡片(card),对话(conversation),和确认(confirmation). 卡片可能是用户故事最明显的表现形式之一, 但并不是最重要的,卡片上通常是很简略的描述客户的需求而非完全的陈述, 需求的细节内容是在"对话"之中获得的. 

下面是一个典型的用户故事，该故事取自一个旅游行业的内部系统　　
	计调人员可以在系统中发布新的旅行线路
后面将会继续使用这个系统作为案例。

那么从用户故事的定义来说， 首先要体现对用户有*价值*， 上面的例子中， “发布旅行线路”即是该用户故事的价值所在。而下面的例子则不能体现出对用户的价值
	这个旅行线路应该存储在MySQL数据库的tour_product表中
在这个描述之中，涉及了过多的实现细节，而用户显然是不关心数据怎样存储的的。
从实践中我们总结出一个合理的用户故事的描述可以通过填充下面的三部分来表现
	作为____, 我想要____, 以便___    
这三部分分别体现了，该用户故事的主体，即受益者，想要实现的功能，以及最终体现业务的价值。那么按照这个思路，我们可以把上面的用户故事写成如下的形式:  
	作为计调人员，我想要在系统中发布新的旅行线路，以便销售人员可以查找并销售这条线路．
按照这样的形式进行分解之后，用户故事就变得清晰很多了，其中第三部分在某些情况下是可以省略，因为有可能是第二部分已经足够清楚表达意图了。

## 故事的粒度
请看这样的一个故事
	销售人员可以搜索正在销售中的旅行线路
这样的一句话十分简单，但是仅以这样一句话作为指南进行开发，显然还不够。开发人员需要更多的细节，比如

1. 销售人员可以按哪些条件进行检索？城市？ 日期？ 关键字？ 
2. 搜索参数是否需要保存？ 
3. 搜索结果是否需要排序？ 如何排序？ 

这时候，我们需要对故事的粒度进行细分。 如果从大的粒度着眼，很多系统也就那么几个用户故事。比如著名的社交网站twitter，其主要的用户故事大概也就是这样的

1. 用户之间可以彼此follow，以形成朋友关系
2. 用户可以发布消息，以便其朋友可以看到
3. 用户可以转发其朋友发布的消息

这些描述都十分简单，似乎没啥指导性的意义，然而不要小看它们，因为它们确实体现出了twitter核心的业务价值。像这样的故事，我们称之为”史诗故事“(Epic)，通常我们从史诗故事入手，将其逐步分解成更多的小故事。回到最上面的例子”销售人员可以搜索正在销售中的旅行线路“这一故事就可以分解成以下几个故事

1. 销售人员可以通过线路的价格，所在城市，起止时间，发布时间，关键字等条件进行搜索。
2. 销售人员可以查看搜索结果中的每条线路的信息，其中应包括是否有折扣，以及折扣条件等，以便根据用户组团人数进行推荐
3. 销售人员可以查看到该线路是由哪位计调人员发布的，以便必要时和计调人员取得联系。

这样的分解应该进行到什么程度呢？这并没有什么绝对的准则，一条可参考的方案是，当这个故事所描述的粒度达到可以进行估算的范围即可。什么是可估算？通常来说，如果我们估计一至两天以内的工作量时会比较有把握，而估计一周的工作量就开始产生较大的偏差，要估算两个月的工作量，那基本就跟猜的没什么两样。

## 加些注释
对于细分过后的故事，我们可以尝试加入一些注释，如果使用纸质的卡片，那么可以讲这些注释卸载卡片背面，如果使用电子文档比如excel的话，就使用注释功能。这些注释是一些提示语句，可以非常简短，例如上面的故事可以加入如下的一些注释:  

* 注意关键字为空或者超长的情况
* 注意关键字中包含特殊字符的情况

这些注释性的描述主要用于帮助开发人员进行测试，以及确认功能已经完全开发完成。要注意这些一定要简短，不要担心信息不够或者无法读懂，因为我们真正关注的是面对面的沟通，如果开发人员拿到卡片之后看不太懂，那么尽可以去找到卡片的作者与之进行交流，从而获得更加完整的信息。我们想要做的，只是一个提示而已。	

## 客户团队
在一个理想的scrum团队中，都有一个专职的人员负责为开发人员的工作排列优先级，回答开发人员所有的问题，在软件发布一部分功能时对其进行使用并给出反馈，写下更多的用户故事等等。然而像这样的”专职“人员，在大多数的项目中都是很难遇到的，原因是业务人员也有很多自己的工作要做，大多数被指派来给开发人员答疑解惑的业务人员都是将其作为”额外“的工作的，他们的本职工作还是要做好才行。所以，我们需要建立一个客户团队。客户团队中包括确保软件满足用户需求的所有人，这意味着客户团队可以包含测试人员，产品经理/项目经理，实际用户和UI设计师。

## 用户故事在开发过程中的流转
相对于过去的项目，使用故事的项目的开发步调会很不一样。使用传统的瀑布是模型的过程是这样的， 书写所有需求 -> 分析需求 -> 设计方案 -> 编码 -> 最终测试 这样形成一个周期。在这样的过程中，客户和用户只在项目开始阶段进行参与，之后就把开发人员抛弃到一边让他们自生自灭，直到最后阶段来验收软件。现如今大家都知道这样的模型是靠不住的，让开发人员自己搞只能创造出各种各样的灾难。    

而在敏捷型的项目当中，我们需要的是客户和用户在项目整个的生命周期中全程参与进来。软件的客户和最终客户应该在编写故事之时承担着非常活跃的角色，尤其是在团队使用极限编程(XP)进行开发时。编写故事的过程可以从考虑系统的用户类别入手，还是以上面的某旅游行业的内部系统软件为例，会包含计调人员，销售人员，行政人员，采购人员，部门管理者等角色，如果有可能的话，最好能够在客户团队当中包含尽可能多的不同的角色，让他们参与进来，从而获得第一手的用户故事。  

组建起客户团队之后，下一步是召开“故事会”这是类似头脑风暴的一种会议，在这个会议上大家集思广益，收集尽可能多的故事，而后对这些故事进行筛选，细分和优先级排列，最终获得一些可供开发人员参考的故事集合，注意此时我们并不需要分析完所有的故事，只要将一部分高优先级的故事提取出来，足够我们开发一阵子（至少是一至两个迭代的周期），就可以了。然后在接下来的开发过程中，我们会进一步的细化其他的故事。客户团队在这段时间内都是高度参与的，他们会协助定义用户故事的测试用例，甚至与开发人员一起编写运行自动化测试的脚本。客户团队要努力确保项目能够达到交付所需产品的目标。  

迭代长度一经确定，开发人员就会估计每轮迭代中可以做多少事情。这个值被称之为开发速率velocity。团队的第一次速率估计很可能是错误的，因为无法事先预知团队的情况，但是没有关系，我们在后面的迭代中会借鉴前面迭代的速率，甚至绘制出速率的曲线图，来勾勒出大致的发布计划。我们无法做到绝对准确，但是在相对准确上是可以逐渐向事实靠拢的。  

当我们拥有了一堆的故事卡片之后, 我们根据其优先级和依赖顺序来将其分成若干堆, 每一堆都是依据一个迭代可能完成的工作量来进行划分的. 在每一轮迭代开始之前,客户团队可以对迭代中的故事卡片进行修正．这样当迭代结束后，我们就会获知开发团队的实际速率，然后使用它重新来重新估计后面的迭代．由于预估的偏差，我们有可能在每个迭代中对卡片进行调整，增加或者移除都有可能．也有可能在实际的开发过程中会发现某些故事之间的相互依赖关系导致不得不把某些卡片提前，而另一些推迟到下一个迭代中．
## 迭代式发布计划
一个发布由一个或者多个迭代组成．我们需要在项目计划的时间表和预期的功能集合之间做出平衡，这个过程就是发布规划．客户团队和开发人员都需要参与其中．　　

第一件事情是为故事排列优先级．优先级排列需要考量一下几个因素：　
* 大部分用户和客户对特定特性的渴望程度
* 小部分重要用户和客户对特定特性的渴望程度
* 故事之间的关系. 

在排列优先级的过程中，开发人员可能和客户团队的意见不同，原因是他们会基于技术风险方面的考虑,或者由于某个故事是其他故事的前置依赖,而建议改变故事的优先级. 客户团队应该倾听他们的观点，但是在随后排列故事优先级时，还是应该以客户组织的利益最大化为第一原则．　　
排列故事优先级时也应该考虑他们的成本．故事的成本应该由开发者给出，这个成本并非绝对的人＊天值，而是一个相对的数字，称之为故事点数．这里强调一个相对概念，一个２个点的故事，其成本会高于１个点的故事，而一个４个点的故事，其成本大约相当于２个点的故事的２倍．  
之后我们可以把评估后的故事列出来，并且形成这样的一个表格
<table>
	<thead>
		<tr><th>故事</th><th>故事点数</th></tr>
	</thead>
	<tbody>
		<tr><td>故事A</td><td>3</td></tr>
		<tr><td>故事B</td><td>5</td></tr>		
		<tr><td>故事C</td><td>5</td></tr>		
		<tr><td>故事D</td><td>3</td></tr>		
		<tr><td>故事E</td><td>1</td></tr>		
		<tr><td>故事F</td><td>8</td></tr>		
		<tr><td>故事G</td><td>5</td></tr>		
		<tr><td>故事H</td><td>5</td></tr>		
		<tr><td>故事I</td><td>5</td></tr>		
		<tr><td>故事J</td><td>2</td></tr>		
	</tbody>
</table>
&nbsp;&nbsp;假设我们开发团队估计的速率是13,那么可以看出上面这些故事需要4个迭代才能完成,其中第二和第三个迭代分别只有12个点的预计工作, 其实没关系, 因为一直我们都强调所有的预估都是相对的, 这样一点偏差并不是什么大问题. 我们将这些故事按照迭代再排列一下
<table>
	<thead>
		<tr><th>迭代</th><th>故事</th><th>故事点数</th></tr>
	</thead>
	<tbody>
		<tr><td>迭代一</td><td>A B C </td><td>13</td></tr>
		<tr><td>迭代二</td><td>D E F </td><td>12</td></tr>
		<tr><td>迭代三</td><td>G H J </td><td>12</td></tr>
		<tr><td>迭代四</td><td>I</td><td>5</td></tr>
	</tbody>
</table>
这里我们看到迭代三中, 我们跳过了优先级更高的J而选择了I, 原因是故事I需要5个点, 如果将其放入迭代三的话, 迭代三就会有15个点, 这超出了我们的预估. 为了保证在每个迭代的结束我们都能够交付全部的故事, 而不是几个半故事, 我们就在优先级和故事规模之间进行了权衡, 选择了将J故事提前到迭代三中完成. 

当然我们还可以有另外一种选择, 那就是前面提到过的将故事细分. 假设我们能够将故事I分解成两部分Y(3个点)和Z(2个点), 那么就能够做出一个更加合理的计划了.
<table>
	<thead>
		<tr><th>迭代</th><th>故事</th><th>故事点数</th></tr>
	</thead>
	<tbody>
		<tr><td>迭代一</td><td>A B C </td><td>13</td></tr>
		<tr><td>迭代二</td><td>D E F </td><td>12</td></tr>
		<tr><td>迭代三</td><td>G H Y </td><td>13</td></tr>
		<tr><td>迭代四</td><td>Z,J</td><td>4</td></tr>
	</tbody>
</table>
## 验收测试
&nbsp;&nbsp;验收测是用来验证实现的用户故事是否符合客户团队的期望．当一轮迭代开始时，开发人员开始编码，同时客户团队开始测试工作．这里与旧的开发模式很不一样，两者是几乎同时进行的．客户团队当中的测试人员是这一过程的主要力量，他们首先需要与业务人员合作，在故事卡上写下测试描述，还需要将这些测试描述转化成自动化测试的脚本加入到自动化测试工具之中，当然有些时候这需要开发人员的帮助．

## 为何采用用户故事
现在我们来总结一下使用用户故事与传统需求分析方法相比的优势在哪里． 

* 用户故事强调口头沟通。
* 相比用例或各种UML图示, 故事更加易于同时被开发和业务人员理解。
* 用户故事的大小适合于做计划。
* 用户故事更适用于迭代开发。
* 用户故事本身鼓励推迟细节, 这使得我们不必过早做出猜测以及在这些猜测上面浪费资源。
* 用户故事更加强调强调团队参与设计。

### 口头沟通的重要性
过去的经验使我们产生一些误解, 认为需求一旦写到书面上就得到了所有人的肯定和确认. 开发人员确切的知道要开发什么, 测试人员知道要测试什么, 更重要的, 客户以为他们一定会得到自己想要的系统. 而事实上恰恰相反, 文字往往使人迷惘，信息的衰减在文字的传递过程中尤为严重．客户最终只会获得开发人员根据他们对文字的理解所开发出的系统，而这可能并不是他们想要的．

### 用户故事更加利于理解
由于用户故事都是使用平时和更加贴近业务的白话来书写, 使得开发人员和用户都能够理解. 相比之下用例和场景描述中的"标准术语"有很多都令普通用户无法理解, 甚至还有好多术语词汇是专门为了写用例而出现的领域用词, 这些词语连开发人员都会觉得拗口．

另一方面上世纪７０年代末的一次研究发现，如果将事物组织成故事，能够增强人们对其理解和记忆的能力，研究的参与者甚至能够清楚的回忆起事件中的各种细节，甚至暗示的情节．

### 用户故事的大小适合做计划
因为用户故事的大小适中,使得对其进行计划变得容易. 而用例和场景设计则通常都太大了, 一个场景中又往往包含了不止一个的功能细节, 而这些功能的优先级又可能有所不同, 因此使得对基于用例和场景的计划变得十分难以取舍. 与之不同的是,用户故事的大小是可以掌控的, 因此可以方便的做出发布规划, 编程, 以及测试.

### 用户故事适合迭代
用户故事与迭代式开发是相辅相成的．在开始开发之前，我们并不需要写出所有的故事，相反我们可以写出一部分的故事之后就开始进行编码和测试，然后按照需要的节奏重复这个过程．从这一点上来说，用户故事的编写本身也可以是迭代式的。这就使得用户故事更加契合于迭代开发。

### 用户故事鼓励延迟细节
使用用户故事的另一个优势在于我们鼓励团队延迟手机细节。这一点其实是上面提到的用迭代的方法编写故事的另一种表现形式。我们不必一次写出所有故事，也不必一次把一个故事写到完美，我们可以逐渐的将其细化，从模糊到清晰，这样的好处在于，我们可以随时根据项目的进展，获得用户的反馈，并使用这些反馈来改进我们的用户故事。通过这样的方式，我们就可以在一定程度上引导用户发现他们自己的需求，一旦我们开了个好头，进入良性的循环之中，我们就可以让需求逐渐的一个个浮出水面。

### 用户故事鼓励团队参与
用户故事由于其表现力强这一特性，使得团队中所有的人都能够迅速的理解并消化其信息。这样一来使得无论开发人员还是用户都能够参与到故事的编写之中，于是能够形成更好的团队合作。这与旧式的分析人员询问业务人员问题并进行记录，之后再独自整理这些记录，产生出用例的方式是迥然不同的。在使用用户故事的团队中，用户不仅是需求提出者，还是产品的设计者，这更能够激发他们的积极性。

### 用户故事的不足
首先，在大型项目当中，随着故事集的不断扩充，故事间的关系会变得错综复杂，难以捉摸。通过使用角色来对故事进行分类和归总，可以部分的解决这个问题，并且应该尽量保证用户故事不要沉迷于细节，直至开发这些故事的时候才去细化他们。

其次，如果开发过程规定要有需求的可追溯性，那么使用往往有些力不从心，毕竟卡片上的记录和注释都有些随意，并且卡片本身也并不适合于归档。在这样的情况下我们采取一些变通，比如我们可以采用电子文档来记录故事，并对这些电子文档进行版本控制，或者采用一些在线的工具来做这些事情。需要注意的是在选择对策的时候，要避免落入文档驱动的圈套之中，始终警醒团队，保持轻量，不要在文档上面花费太多的时间，或者使用那些学习曲线很高的工具。我们的项目中采用过的一些相当优秀的工具，比如trello，这是一个在线的白板模拟系统。它的功能十分纯粹，这使得它的上手也非常简单，像这样的工具是值得尝试的。

最后，就是对于团队规模如果是特大型的多团队结构，用户故事就不那么容易使用了。因为此时口头上的沟通成本已经相当之高。这种情况下，我们确实需要把交流记录下来，不然难以保证信息在大型团队里面得到充分的共享。